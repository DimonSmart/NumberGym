# Расширение модели изучения чисел до числовых концепций

Ниже — несколько вариантов, как расширить текущую модель данных и тренировки, чтобы поддерживать **числовые концепции** (время, телефонные номера, вес, цены, дроби, проценты и т. д.). Цель — дробить большие темы на под-навыки, учитывать прогресс и зависимости (например, использовать только уже изученные числа), а также уметь «пропускать» задание, если базовые знания не готовы.

## 1) Общая идея: концепции → под-навыки → генераторы

**Ключевое разделение:**
- **Концепция (Concept)** — крупная тема: «Время», «Сложение», «Телефонные номера», «Дроби».
- **Под-навык (Skill/ConceptPart)** — часть темы, которую можно изучать отдельно: «ровное время», «четверти», «половины», «формат 24 часа», «сложение двузначных», «телефонный номер: группы по 3–2–2».
- **Генератор заданий (TaskGenerator)** — правило, по которому создаются конкретные задания (время 10:15, номер +7 921 123-45-67 и т. д.).

**Плюсы:**
- Позволяет дробить большие темы.
- Можно адаптивно повышать сложность.
- Можно централизованно проверять «готовность» (есть ли изученные числа/под-навыки).

---

## 2) Вариант A: Универсальная модель «Концепции → Под-навыки → Элементы»

### Сущности
- **Concept**
  - `id`, `name`, `description`
  - Пример: `time`, `addition`, `phone_number`

- **Skill**
  - `id`, `concept_id`, `name`, `description`, `difficulty`
  - Пример: `time_quarters`, `time_exact`, `phone_grouping_3_3_2`

- **Generator**
  - `id`, `skill_id`, `params_json` (настройки генерации)
  - Пример: для времени — список допустимых минут, формат фразы, правило речи

- **Item (GeneratedTask)**
  - `id`, `skill_id`, `payload_json` (конкретные данные задачи)
  - Пример: `{ "time": "10:15", "phrase": "четверть одиннадцатого" }`

- **Mastery** (прогресс)
  - `user_id`, `skill_id`, `score`, `last_seen`, `streak`, `confidence`

- **Attempt** (ответы)
  - `user_id`, `item_id`, `result` (правильно/неправильно/пропуск), `timestamp`, `input_text`

### Как это работает
1. Пользователь выбирает очередной **Skill**.
2. Проверяется, можно ли выполнить генерацию (например, есть ли уже изученные числа для примера сложения или времени).
3. Если «готовности» нет — **Item** помечается как «пропуск» и переносится в конец очереди.
4. Если готовность есть — генерируется **Item** и идет в тренировку.

**Пример для сложения:**
- Skill `addition_single_digit` зависит от изученных чисел 1–9.
- Генератор берет только те числа, которые пользователь уже освоил.

**Пример для времени:**
- Skill `time_quarters` → генератор выбирает минуты {15, 45} и часы из уже изученных чисел.

**Плюсы:** универсальная модель, проста в реализации.
**Минусы:** для некоторых тем (например, телефоны) придется дополнительно продумывать критерии «правильности» ответа.

---

## 3) Вариант B: Модель «Концепции как граф навыков»

В этом варианте навыки организуются как **граф зависимостей**.

### Сущности
- **ConceptNode**
  - `id`, `name`, `type` (concept/skill)
- **PrerequisiteEdge**
  - `from_id`, `to_id`, `condition`

### Пример
- Узел: `time` → подузлы `time_exact`, `time_half`, `time_quarter`, `time_24h`.
- Зависимость: `time_quarter` зависит от `time_exact` + понимания чисел до 12.

### Как тренировать
- Очередь формируется из узлов, у которых **выполнены зависимости**.
- Если зависимость не выполнена → узел откладывается.
- Это дает гибкую дорожную карту обучения.

**Плюсы:** очень хорошо масштабируется.
**Минусы:** сложнее для реализации.

---

## 4) Вариант C: Модель «Шаблоны и правила речи»

Здесь вместо явных «под-навыков» можно описывать **речевые шаблоны**, из которых строятся задания.

### Пример для времени
- Шаблон: `"{hour} {minute} минут"`
- Шаблон: `"четверть {next_hour}"`
- Шаблон: `"половина {next_hour}"`

Каждый шаблон — это мини-навык. Можно отмечать прогресс отдельно по каждому шаблону.

**Плюсы:** очень удобно для языковых аспектов.
**Минусы:** требует отдельной логики шаблонов.

---

## 5) Как разбивать «большие» концепции

### Время
**Под-навыки:**
- Ровное время (10:00, 11:00)
- Половина часа (10:30)
- Четверти (10:15, 10:45)
- Произвольные минуты (10:21)
- Формат 24 часа
- Разговорные формы ("без четверти", "половина одиннадцатого")

**Генерация:**
- Проверять, что часы и минуты входят в уже изученные числа.
- Если нет → переносить задание.

### Телефонные номера
**Проблема:** много цифр, важно научить "ритм" и группировку.

**Под-навыки:**
- Озвучивание цифр по одной (0–9)
- Группировки: 2-2, 3-3-2, 3-2-2
- Международный формат (+7/8)
- Код оператора (три цифры)
- Полный номер с паузами

**Проверка:**
- Не обязательно требовать «идеальную строку», можно сравнивать **последовательность цифр**.
- Ошибки группировки не всегда критичны, можно вводить **мягкий скоринг**.

### Вес / деньги / проценты
**Под-навыки:**
- Простые формы: "2 кг", "5 рублей"
- Сложные формы: "2,5 кг", "5 рублей 20 копеек"
- Сравнение: "больше/меньше"

**Генерация:**
- Использовать дробные части только после освоения целых чисел.

### Дроби
**Под-навыки:**
- Половина/четверть как отдельные концепты
- Простые дроби (1/2, 1/3)
- Сложные дроби (2/3, 3/4)

---

## 6) Как хранить прогресс (не только «6 раз правильно»)

Для больших концепций полезно хранить **несколько параметров**:
- **Понимание (accuracy)** — процент правильных ответов.
- **Стабильность (streak)** — подряд правильные ответы.
- **Скорость (response_time)** — среднее время ответа.
- **Устойчивость (confidence)** — модель уверенности, растет при повторных успешных ответах.

Пример статуса навыка:

```
mastery = {
  accuracy: 0.78,
  streak: 3,
  confidence: 0.62,
  last_seen: 2024-04-20
}
```

Это позволит более гибко решать, когда переводить навык в «изученные».

---

## 7) Логика очереди заданий

### Принципы
- **Готовность**: если навык требует чисел, то без этих чисел задача не появляется.
- **Перемешивание**: если времени много, вставлять более простые элементы для закрепления.
- **Пропуск**: если пользователь «пролистнул» — помечать как neutral и возвращать позже.

### Пример алгоритма
1. Выбираем следующий **Skill** из очереди.
2. Проверяем readiness (доступные числа, зависимости).
3. Если readiness = false → переносим в конец очереди с пометкой "skipped".
4. Если readiness = true → генерируем **Item**, проверяем ответ, обновляем Mastery.

---

## 8) Краткий пример данных

```
Concept: time
Skill: time_quarters
Generator: { minutes: [15, 45], phrases: ["четверть {next_hour}", "без четверти {next_hour}"] }
Mastery: accuracy=0.65, streak=2
```

```
Concept: phone_number
Skill: phone_grouping_3_3_2
Generator: { format: "+7 9xx xxx-xx-xx" }
```

---

## 9) Итоговые рекомендации

1. Введите **иерархию Concept → Skill → Generator**.
2. Для каждой большой темы (время, телефон, деньги) заведите **отдельные под-навыки**.
3. Используйте **граф зависимостей** или простые условия readiness.
4. Храните прогресс не одним числом, а несколькими метриками (accuracy, confidence, streak).
5. Для телефонов используйте **проверку по цифрам**, а не по точной фразе.
6. Делайте «мягкие» критерии успеха: частично правильный ответ может увеличивать confidence.

---

Если нужно, могу предложить конкретный формат JSON-структур или описать схему БД.

---

# Дополнение: зависимости концепций для числовых разрядов и новая логика успешности

Ниже — предложенный **первый шаг** для внедрения концепций числовых разрядов (цифры, двузначные, трехзначные, сотни, тысячи и т. д.) с **явными зависимостями** и **гибкими порогами успешности**.

## 10) Базовый набор концепций чисел и их названия

Чтобы названия не конфликтовали и были строго однозначны, предлагаю следующую схему именования:

- `digits_0_9` — одиночные цифры от 0 до 9.
- `numbers_10_99` — двузначные числа от 10 до 99.
- `numbers_100_999` — трехзначные числа от 100 до 999.
- `hundreds_exact` — сотни (100, 200, 300, ... 900).
- `thousands_exact` — тысячи (1000, 2000, ... 9000).
- `tens_of_thousands` — десятки тысяч (10 000, 20 000, ... 90 000).

Если позже появятся тематические концепции (время, телефон, вес), их можно называть по домену: `time_*`, `phone_*`, `money_*`.

## 11) Как описывать зависимости: полная концепция или поднабор

Для каждой концепции нужно уметь задавать зависимости **двух типов**:

1. **Зависимость от всей концепции** (hard): нужно, чтобы концепция полностью выучена.
2. **Зависимость от поднабора элементов** (soft): достаточно, чтобы выучены конкретные элементы из другой концепции.

Пример требований для `numbers_100_999`:
- `hard` зависимость от `digits_0_9` (все цифры).
- `soft` зависимость от `numbers_10_99` (только те двузначные, которые реально используются при генерации).

### Формат зависимостей (концептуально)

```
concept_dependency = {
  concept: "numbers_10_99",
  type: "soft",
  requirement: {
    mode: "subset",
    selector: "used_in_generation"
  }
}
```

Для `hard` зависимости:

```
concept_dependency = {
  concept: "digits_0_9",
  type: "hard",
  requirement: { mode: "complete" }
}
```

### Логика в тренировке

- Если **hard** зависимость не выполнена — задача не показывается.
- Если **soft** зависимость не выполнена полностью — генератор берет только доступные элементы.

Таким образом, если пользователь знает число 55 и сотню 100, можно генерировать 150, даже если не все двузначные выучены.

## 12) Пример генерации трехзначных чисел с учетом зависимости

Для `numbers_100_999` предлагается генератор:
- Сотни берутся из `hundreds_exact`, которые уже выучены (например, 100).
- Десятки и единицы берутся из выученных двузначных и однозначных.

Пример:
- Выучены `digits_0_9` = {1, 5}
- Выучены `numbers_10_99` = {55}
- Выучены `hundreds_exact` = {100}

Генератор может выдавать: 150, 155.

## 13) Расширенная модель успешности (mastery rules)

Нужно хранить не просто «6 правильных», а **набор правил**, зависящих от концепции.

### Пример правил:

```
mastery_rule = {
  window: 10,
  min_accuracy: 0.9,
  min_streak: 5,
  allow_skips: 1
}
```

### Идея по настройкам:
- **Цифры (digits_0_9)**: window=10, min_accuracy=1.0.
- **Двузначные**: window=10, min_accuracy=0.9.
- **Трехзначные**: window=10, min_accuracy=0.85.
- **Телефонные номера**: window=10, min_accuracy=0.7, allow_skips=2 (из-за длинного ввода).

Это позволит гибко адаптировать требования под сложность темы.

## 14) Виды тренировок как отдельная сущность

Предлагаю явно описывать **training_type**:

- `read_aloud` — произношение числа или конструкции.
- `recognition` — узнать/выбрать правильный вариант.
- `construction` — собрать число из частей (например, 100 + 50).

Каждый training_type имеет свои правила успешности и генераторы.

## 15) План внедрения поддержки концепций числовых разрядов

1. **Ввести сущность Concept** с явным типом и уникальным именем (см. список выше).
2. **Добавить зависимости** между концепциями с типами `hard` и `soft`.
3. **Добавить генераторы** для `numbers_100_999`, использующие только доступные элементы.
4. **Добавить правила успешности (mastery_rule)** с разными порогами для разных концепций.
5. **Расширить очередь заданий**: если hard-зависимость не выполнена — пропуск, если soft — уменьшить пространство генерации.
6. **Сохранить историю попыток** для вычисления `min_accuracy` на window (последние N ответов).

Если нужно, могу расписать точные структуры JSON/БД и примеры интерфейсов генераторов.
